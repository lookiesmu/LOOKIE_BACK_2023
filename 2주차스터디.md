# JPA annotations 설명

## annotation ##

- @GeneratedValue: 객체의 아이디 필드의 성성 전략을 설정하는 에노테이션
- GeneratedType:

  모드 설명
    - Auto (Default)    JPA가 알아서 하겠음
    - IDENTITY 기본키 생성을 DB에게 위임
    - SEQUENCE DB에서 `SEQUENCE`를 지원한다면, 사용 아니라면 Table Mode
    - TABLE DB에 키용 테이블이 생김 (hibernate_sequence)

- @Column(name = "member_id"): db에 컬럼이름 맵핑할 때 사용함
    - @Embedded, @Embeddable 임베디드 타입을 적용하려면 새로운 Class를 만들고 해당 클래스에 임베디드 타입으로 묶으려던 Attribute들을 넣어준 뒤 @Embeddable를
      붙여줘야합니다.
  > 사용 방법 - @Embeddable : 값 타입을 정의하는 곳에 표시 - @Embedded : 값 타입을 사용하는 곳에 표시 아래의 임베디드 타입을 적용한 코드를 보면 주소의 관련된 속성들이 하나의 타입으로 바껴 사용되는 것을 볼 수 있습니다. 이를 보면 위의 코드보다 더욱 더 객체지향적이고 응집도 있는 코드로 바뀐 것을 확인할 수 있습니다.

- @JoinColumn(name = "member_id") : 외래키를 맵핑할 때 사용함.
- @Enumerated(EnumType.STRING) : enum type 을 mapping 할 때 사용함. string 으로 정해야 db에 문자열로 저장됨

- @Inheritance(strategy = InheritanceType.SINGLE_TABLE)

---
**각각의 테이블로 변환하는 조인 전략(JOINED)** : 즉 ORM 에서 객체를 생성할때 두개의 테이블을 조회해서 가져오게 된다.

**통합 테이블로 변환하는 단일 테이블 전략(SINGLE_TABLE)** : 객체를 구분할 수 있는 추가적인 컬럼이 필요하다.

**서브타입 테이블로 변환하는 구현 클래스마다 테이블을 생성하는 전략(TABLE_PER_CLASS)** : 가장 기본적이 전략이지만 과도한 table 이 발생할 수 있지만 그래도 탐색의 깊이를 낮추는 면에서 베스트가
아닌가.
---

- @DiscriminatorColumn(name = "dtype"): 말 그대로 다른 객체를 구분하기 위해서 사용하는 칼럼.
    - @ManyToMany 다대 다 관계를 맵핑하는 에노테이션

      ```java
      @JoinTable(name = "category_item",
      joinColumns = @JoinColumn(name = "category_id"),
      inverseJoinColumns = @JoinColumn(name = "item_id"))
      class sdfsdf{}
      ```
      위의 코드는 M:N 관계에서 두개의 칼럼을 합쳐서 view를 생성할 때 사용됨.
      > @ManyToMany 는 편리한 것 같지만, 중간 테이블( CATEGORY_ITEM )에 컬럼을 추가할 수 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 실무에서 사용하기에는 한계가 있다. 중간 엔티티( CategoryItem 를 만들고 @ManyToOne , @OneToMany 로 매핑해서 사용하자. 정리하면 대다대 매핑을 일대다, 다대일 매핑으로 풀어내서 사용하자.

      라고 김영한 씨가 말하는데 과연 이 연관관계를 풀어서 사용한다는게 어떻게 하는거냐면 : 1:N M:1 로 풀어서 사용함.

      ### 엔티티 설계시 주의점
    - 엔티티에는 가급적 Setter를 사용하지 말자 Setter가 모두 열려있다. 변경 포인트가 너무 많아서, 유지보수가 어렵다. 나중에 리펙토링으로 Setter 제거   
      모든 연관관계는 지연로딩으로 설정!

    - 즉시로딩( EAGER )은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.   
      특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다. 실무에서 모든 연관관계는 지연로딩( LAZY )으로 설정해야 한다. 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티
      그래프 기능을 사용한다.
    - 엔티티 그래프 : 일부 객체의 정보를 쿼리할 범위를 설정해서 가져올 수 있게해줌.

    - @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다. 컬렉션은 필드에서 초기화 하자. 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
      null 문제에서 안전하다. 하이버네이트는 엔티티를 영속화 할 때, 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.
    - 만약 getOrders() 처럼 임의의 메서드에서 컬력션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.

### JPQL을 실행할 때 N+1

- 하나의 쿼리문의 결과로 N개의 쿼리 문이 생성이 되는 경우.

### 무한참조 요청

- 양방향 관계가 설정되어 있을 때 서로가 서로를 참조해서 무한 쿼리가 발생하는 문제가 생긴다.
    - 해결책은??
        - 정답을 아는 분은 답변 바람(DTO) - 이유까지 설명 바람. DTO에 정보를 저장하는 과정에서
            - 알려주세요 교수님...

### 리플렉션

- 생성된 객체의 타입이 불분명 하더라도 일부 다른 객체에 내장된 method 를 사용할 수 있게 해주는 것
- 교수님 알려주세요...

```@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyNonTransactionalTests {

    // ...

}
```

Data JPA tests may also inject a TestEntityManager bean, which provides an alternative to the standard JPA EntityManager
that is specifically designed for tests.

TestEntityManager can also be auto-configured to any of your Spring-based test class by adding
@AutoConfigureTestEntityManager. When doing so, make sure that your test is running in a transaction, for instance by
adding @Transactional on your test class or method.

