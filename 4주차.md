### 엔티티에는 4 가지 상태가 있다.

- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계 없는 상태
  - 엔티티 객체를 생성
    순수한 객체 상태, 아직 저장하지 않음
    영속성 컨텍스트나 DB와 상관이 없다.
- 영속(managed): 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트에 저장이 된 상태
    Entity가 영속성 컨텍스트에 의해 관리되는 상태
    영속상태라 하더라도 바로 DB에 적용되지 않음
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
    영속성 컨텍스트에서 지운 상태
- 삭제(removed): 삭제된 상태  
  - 실제 DB 삭제를 요청한 상태


비영속 상태는 순수한 객체 상태이며 New 로 생성을 하고 아직 EntityManager 와 
어떤 관련도 없는 상태라고 할 수 있다. 아래 코드에서 em.persist 메소드 호출전까지는 단지
Member의 인스턴스를 생성하여 id, 이름, 나이까지만 set 했을 뿐 비영속 상태라고 할 수 있다.


## 더티 체킹 (Dirty Checking)이란?

**jpa context 에 저장되어 있는 객체의 snapshot 과 차이점이 발견되면 이를 감지하고 update 쿼리를 자동으로 날리는 것이다.**
- 조건 객체의 상태가  위에서 설명한 영속상태 일때만이다. 즉 새롭게 준영속 상태도 적용이 되지 않는다. (준영속은 jpa 의 식별자는 있지만 영속성 컨텍스트에는
존재하지 않는 경우이다)
- 단점은 모든 필드를 없데이트해 필드의 데이터가 많을 경우 부담이 될 수 있다는것 이를 해결하기 위해서서는 ????
  - ```@Getter
    @NoArgsConstructor
    @Entity
    @DynamicUpdate // 변경한 필드만 대응
    public class Pay {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String tradeNo;
    private long amount;
    ```
    위 테이블과 같이 @DynamicUpdate // 변경한 필드만 대응 을 명시한다면 변경된 필드만을 update 쿼리가 발생한다.!!!

